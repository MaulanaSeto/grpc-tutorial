# Refleksi
1. Perbedaan utama antara metode RPC *unary*, *server streaming*, dan *bi-directional streaming* terletak pada pola komunikasi antara klien dan server.
   1) Dalam RPC *unary*, klien mengirim satu permintaan dan menerima satu respons dari server. Metode ini sesuai untuk operasi sederhana seperti pengambilan data tunggal.
   2) Pada *server streaming* RPC, klien mengirim satu permintaan dan menerima aliran respons dari server sesuai untuk situasi di mana server perlu mengirimkan serangkaian data berkelanjutan, seperti streaming data *real-time*.
   3) Terakhir, *bi-directional streaming* RPC memungkinkan klien dan server untuk mengirim dan menerima aliran pesan secara independen sehingga menjadikannya ideal untuk aplikasi yang memerlukan komunikasi dua arah yang berkelanjutan, seperti aplikasi chat atau kolaborasi waktu nyata.
2. Dalam mengimplementasi layanan gRPC dengan Rust, pertimbangan keamanan meliputi autentikasi, otorisasi, dan enkripsi data. Autentikasi memastikan bahwa hanya klien yang sah yang dapat mengakses layanan, yang dapat dicapai melalui mekanisme seperti TLS atau token berbasis OAuth. Otorisasi mengatur hak akses klien terhadap sumber daya tertentu untuk memastikan bahwa klien hanya dapat melakukan operasi yang diizinkan. Enkripsi data, biasanya melalui TLS, melindungi data yang ditransmisikan antara klien dan server dari penyadapan atau manipulasi oleh pihak ketiga. Penerapan praktik keamanan ini penting untuk menjaga integritas dan kerahasiaan komunikasi dalam layanan gRPC.
3. Menangani *bi-directional streaming* dalam gRPC menggunakan Rust dapat menghadirkan tantangan seperti pengelolaan aliran data yang asinkron dan penanganan kesalahan secara efisien. Dalam aplikasi seperti chat, memastikan bahwa pesan dikirim dan diterima dalam urutan yang benar serta menangani klien yang terputus secara tiba-tiba memerlukan perhatian khusus pada implementasi logika asinkron dan penggunaan fitur seperti sinkronisasi dan *buffering*. Selain itu, memastikan bahwa sumber daya seperti koneksi dan *buffer* dikelola dengan benar untuk mencegah kebocoran memori atau penurunan kinerja adalah aspek penting dalam pengembangan layanan gRPC dengan *bi-directional streaming*.
4. Penggunaan `tokio_stream::wrappers::ReceiverStream` dalam layanan gRPC Rust menawarkan keuntungan seperti integrasi yang lebih mudah dengan ekosistem Tokio dan penyederhanaan dalam mengubah *receiver* menjadi *stream* yang dapat digunakan oleh gRPC. Namun, ada beberapa kelemahan yang perlu dipertimbangkan. Misalnya, penggunaan ReceiverStream dapat menimbulkan tantangan dalam penanganan kesalahan dan pengelolaan aliran data yang kompleks, terutama jika tidak dikelola dengan hati-hati. Hal ini dapat menyebabkan kebocoran sumber daya atau perilaku tak terduga dalam aplikasi.
5. Untuk memfasilitasi penggunaan kembali kode dan modularitas dalam pengembangan layanan gRPC dengan Rust, struktur kode sebaiknya dibagi menjadi beberapa modul yang terpisah berdasarkan fungsionalitas, seperti definisi protokol, implementasi layanan, dan konfigurasi server. Dengan pendekatan ini, setiap komponen dapat dikembangkan dan diuji secara independen agar yang meningkatkan keterbacaan, pemeliharaan, dan kemampuan untuk memperluas kode seiring waktu.
6. Solusi yang dapat diterapkan adalah mengubah implementasi menjadi *server streaming*, bukan lagi *unary*. Hal ini bertujuan untuk memungkinkan pengiriman data yang kompleks secara lebih efisien dan mempercepat proses tersebut, sekaligus mengurangi *overhead* yang timbul akibat pembuatan koneksi berulang antara klien dan server.
7. Adopsi gRPC sebagai protokol komunikasi dalam sistem terdistribusi mempengaruhi arsitektur dan desain dengan menyediakan komunikasi yang efisien dan mendukung berbagai bahasa pemrograman. Namun, integrasi dengan teknologi lain seperti REST dapat menimbulkan tantangan, terutama dalam menyelaraskan skema data dan mekanisme komunikasi yang berbeda. Oleh karena itu, diperlukan strategi integrasi yang matang untuk memastikan interoperabilitas yang optimal dalam lingkungan yang heterogen.
8. Penggunaan HTTP/2 sebagai protokol dasar gRPC menawarkan keunggulan dibandingkan HTTP/1.1 atau HTTP/1.1 dengan WebSocket dalam hal efisiensi komunikasi, dukungan streaming dua arah, dan pengurangan latensi. Namun, tantangan seperti dukungan terbatas di peramban web dan kompleksitas implementasi dapat menjadi pertimbangan penting dalam memilih protokol yang sesuai untuk kebutuhan spesifik aplikasi.
9. Model permintaan-respons pada REST API membatasi komunikasi *real-time* karena setiap permintaan klien harus menunggu respons dari server sebelum melanjutkan. Sebaliknya, gRPC dengan kemampuan *streaming* dua arah memungkinkan klien dan server untuk mengirim dan menerima data secara simultan sehingga meningkatkan responsivitas dan efisiensi dalam aplikasi yang memerlukan komunikasi *real-time*.
10. Pendekatan berbasis skema pada gRPC menggunakan Protocol Buffers memberi struktur data yang ketat dan efisien untuk meningkatkan kecepatan serialisasi dan deserialisasi. Namun, ini memerlukan definisi skema yang eksplisit dan dapat mengurangi fleksibilitas. Sebaliknya, JSON dalam REST API menawarkan fleksibilitas tanpa skema yang ketat sehingga memudahkan integrasi dengan berbagai sistem, tetapi dapat mengorbankan efisiensi dan kecepatan pemrosesan data.  
